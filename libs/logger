#! /usr/bin/env bash

# VERSION=v1.1.1

case "${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}" in
    [1-3].* | 4.[1-3] )
        >&2 echo "Least required version of bash is 4.4."
        exit 1
    ;;
esac

declare -A __LOGGER_LEVELS_MAP=( [A]=0 [T]=1 [D]=2 [I]=3 [N]=4 [W]=5 [E]=6 [C]=7 )

function logger::__print_call_stack() {
    local stack_size="${#FUNCNAME[@]}"

    >&2 echo
    >&2 echo "Stack trace:"

    local i=0

    for (( i=$(( stack_size - 1 )); i >= 2; i-- )); do
        local function_name="${FUNCNAME[$(( i - 1 ))]:-"MAIN"}"
        local source_line_number="${BASH_LINENO[$(( i - 1 ))]}"
        local function_source="${BASH_SOURCE[$i]:-"non_file_source"}"

        # TODO: align to right
        >&2 echo -n "   "
        >&2 echo "$(( stack_size - i )): ${function_source}:${source_line_number} > ${function_name}()"
    done
}

function logger::__message() {
    local level="${1}"
    local message="${2}"

    local datetime="\D{%d.%m.%Y %H:%M:%S}"
    local line="[${datetime@P}] ${level}: ${message}"

    if [[ -z "${__LOGGER_FILEPATH+_}" ]]; then
        >&2 echo "${line}"
    else
        echo "${line}" >> "${__LOGGER_FILEPATH}" || {
            # if saving log message to file fails, print it to STDERR
            >&2 echo "[${datetime@P}] C: Cannot write to log file '${__LOGGER_FILEPATH}' anymore."
            >&2 echo "${line}"
        }
    fi
}

function logger::__terminate() {
    local message="${1}"

    logger::__message "C" "${message}"
    logger::__print_call_stack

    exit 1
}

function logger::__is_global_level_set() {
    if [[ -z "${__LOGGER_LEVEL+_}" ]]; then
        logger::__terminate "Global level is not set."
    fi
}

function logger::__validate_level() {
    local level="${1}"

    if [[ -z "${__LOGGER_LEVELS_MAP[${level}]+_}" ]]; then
        logger::__terminate "Level '${level}' is not supported."
    fi
}

function logger::__prepare_log() {
    local log_filepath="${1}"

    if [[ -d "${log_filepath}" ]]; then
        logger::__terminate "'${log_filepath}' is a directory."
    elif [[ -e "${log_filepath}" ]] && ! [[ -w "${log_filepath}" ]]; then
        logger::__terminate "Log file '${log_filepath}' is not writable."
    fi

    if [[ -w "${log_filepath}" ]]; then
        return
    fi

    local log_dirpath="$(dirname "${log_filepath}")"

    if [[ ! -d "${log_dirpath}" ]]; then
        logger::log "I" "Creating log directory '${log_dirpath}'."
        mkdir -p "${log_dirpath}" || logger::__terminate "Cannot create log directory '${log_dirpath}'."
    fi

    touch "${log_filepath}" || logger::__terminate "Cannot create log file '${log_filepath}'."
}

function logger::init() {
    local level="${1}"
    local log_filepath=""

    logger::__validate_level "${level}"

    __LOGGER_LEVEL="${level}"

    if [[ ${#} -eq 2 ]]; then
        log_filepath="${2}"

        logger::__prepare_log "${log_filepath}"

        __LOGGER_FILEPATH="${log_filepath}"
    fi
}

function logger::log() {
    local level="${1}"
    local message="${@:2}"

    logger::__is_global_level_set
    logger::__validate_level "${level}"

    # level A is allowed only for
    if [[ "${level}" == "A" ]]; then
        logger::__terminate "Message's level cannot be set to A."
    fi

    if [[ ${__LOGGER_LEVELS_MAP[${level}]} -lt ${__LOGGER_LEVELS_MAP[${__LOGGER_LEVEL}]} ]]; then
        return
    fi

    logger::__message "${level}" "${message}"
}
